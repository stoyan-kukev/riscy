/* ==========================================================================
   1. TOP LEVEL
   ========================================================================== */
program = { declaration };

block = "{" , { statement } , "}";

statement = declaration
          | if_stmt
          | while_stmt
          | for_stmt
          | switch_stmt
          | return_stmt
          | break_stmt
          | continue_stmt
          | defer_stmt
          | expression_stmt;

/* ==========================================================================
   2. DECLARATIONS
   ========================================================================== */
declaration = [ "pub" ]
            , [ "extern" | "export" ]
            , [ "linksection" , "(" , string_literal , ")" ]
            , ( "const" | "var" ) , identifier
            , [ ":" , type_expr ]
            , [ "align" , "(" , expression , ")" ]
            , [ "=" , expression ]
            , ";";

/* ==========================================================================
   3. CONTROL FLOW
   ========================================================================== */
defer_stmt = ( "defer" | "errdefer" ) , ( statement | block );

if_stmt = "if" , "(" , expression , ")" , block , [ "else" , ( block | if_stmt ) ];

while_stmt = "while" , "(" , expression , ")" , block;

for_stmt = "for" , "(" , for_init , [ expression ] , ";" , [ expression ] , ")" , block;
for_init = declaration | expression_stmt | ";";

return_stmt = "return" , [ expression ] , ";";
break_stmt = "break" , ";";
continue_stmt = "continue" , ";";
expression_stmt = expression , ";";

switch_stmt = "switch" , "(" , expression , ")" , "{" , { switch_prong } , "}";

switch_prong = switch_patterns , "=>" , ( statement | block ) , ",";
switch_patterns = "else"
                | switch_item , { "," , switch_item };

switch_item = expression , [ "..." , expression ];

/* ==========================================================================
   4. TYPES
   ========================================================================== */
type_expr = type_prefix , type_core;

/* Recursive prefixes: *T, ~T (volatile), ?T, !T, [*]T, [~]T, allowzero, align(N) */
type_prefix = { pointer_prefix | "?" | "!" | multi_prefix | "allowzero" | "align" , "(" , expression , ")" };

pointer_prefix = "*" | "~"; /* * = normal, ~ = volatile */
multi_prefix   = "[" , ( "*" | "~" ) , "]";

type_core = identifier
          | struct_def
          | union_def
          | enum_def
          | "[" , int_literal , "]" , type_expr /* e.g. [N]u8 */
          | "fn" , [ "." , identifier ] , "(" , [ param_list ] , ")" , type_expr;

/* Structs: struct, struct.packed, struct.c_abi */
struct_def = "struct" , [ "." , ( "packed" | "c_abi" ) ] , "{" , { container_decl } , "}";

/* Unions: union, union.c_abi */
union_def = "union" , [ "." , "c_abi" ] , "{" , { container_decl } , "}";

/* Fields or Nested Decls */
container_decl = field_decl
               | declaration;

field_decl = identifier , ":" , type_expr , ",";

enum_def = "enum" , [ type_expr ] , "{" , { identifier , "," } , "}";

/* ==========================================================================
   5. EXPRESSIONS (Strict Boolean & Precedence)
   ========================================================================== */
expression = assignment;

assignment = logical_or , [ "=" , assignment ];

/* Level 1: Boolean Logic */
logical_or  = logical_and , { "or" , logical_and };
logical_and = equality , { "and" , equality };

/* Level 2: Comparisons */
equality    = comparison , { ( "==" | "!=" ) , comparison };
comparison  = bitwise_or , { ( "<" | ">" | "<=" | ">=" ) , bitwise_or };

/* Level 3: Bitwise Math */
bitwise_or  = bitwise_xor , { "|" , bitwise_xor };
bitwise_xor = bitwise_and , { "^" , bitwise_and };
bitwise_and = bitwise_shift , { "&" , bitwise_shift };

/* Level 4: Arithmetic */
bitwise_shift = term , { ( "<<" | ">>" ) , term };
term        = factor , { ( "+" | "-" ) , factor };
factor      = unary , { ( "*" | "/" | "%" ) , unary };

/* Level 5: Unary */
unary = ( "-" | "not" | "~" ) , unary
      | postfix;

/* Level 6: Postfix Chain */
postfix = primary , { suffix_op };

suffix_op = "." , "*"                 /* Dereference */
          | "." , "?"                 /* Unwrap Optional (Panic) */
          | "." , "!"                 /* Unwrap Error (Propagate) */
          | "." , identifier          /* Field Access */
          | "[" , expression , "]"    /* Array Index */
          | "(" , [ arg_list ] , ")"  /* Function Call */;

primary = int_literal
        | string_literal
        | identifier
        | "(" , expression , ")"
        | function_literal
        | builtin_call
        | asm_block
        | struct_init;

/* ==========================================================================
   6. LITERALS
   ========================================================================== */
function_literal = "fn" , [ "." , identifier ] , "(" , [ param_list ] , ")" , type_expr , block;
param_list = param , { "," , param };
param = identifier , ":" , type_expr;

arg_list = expression , { "," , expression };

asm_block = "asm" , [ "." , "pure" ] , "{" , string_literal , [ asm_constraints ] , "}";
asm_constraints = ":" , string_literal , [ ":" , string_literal ];

builtin_call = "@" , identifier , "(" , [ arg_list ] , ")";

struct_init = "." , "{" , { field_init } , "}";
field_init = "." , identifier , "=" , expression , ",";
